#!/usr/bin/env python3
"""Auto-generate targets.txt entries that match the local Debian host."""
from __future__ import annotations

import argparse
import ipaddress
import os
import socket
import subprocess
import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import Path
from typing import Iterable, List, Optional


@dataclass
class InterfaceInfo:
    name: str
    cidr: str
    ip: str
    network: Optional[str]
    scope: str
    is_loopback: bool


IP_CMD = os.environ.get("IP_COMMAND", "ip")


def _run_ip_command() -> str:
    return subprocess.check_output([IP_CMD, "-o", "-4", "addr", "show"], text=True)


def discover_interfaces() -> List[InterfaceInfo]:
    lines: List[str] = []
    try:
        output = _run_ip_command()
        lines = [line.strip() for line in output.splitlines() if line.strip()]
    except (FileNotFoundError, subprocess.CalledProcessError):
        return []

    infos: List[InterfaceInfo] = []
    for line in lines:
        parts = line.split()
        if len(parts) < 4:
            continue
        iface = parts[1]
        cidr = parts[3]
        try:
            iface_ip = ipaddress.ip_interface(cidr)
        except ValueError:
            continue
        scope = ""
        if "scope" in parts:
            idx = parts.index("scope")
            if idx + 1 < len(parts):
                scope = parts[idx + 1]
        infos.append(
            InterfaceInfo(
                name=iface,
                cidr=cidr,
                ip=str(iface_ip.ip),
                network=str(iface_ip.network) if iface_ip.network else None,
                scope=scope or "unknown",
                is_loopback=iface_ip.ip.is_loopback,
            )
        )
    return infos


def fallback_interface_guess() -> Optional[InterfaceInfo]:
    ip_value: Optional[str] = None
    try:
        hostname_ips = subprocess.check_output(["hostname", "-I"], text=True).strip()
        if hostname_ips:
            ip_value = hostname_ips.split()[0]
    except (FileNotFoundError, subprocess.CalledProcessError):
        pass

    if not ip_value:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.connect(("8.8.8.8", 80))
            ip_value = sock.getsockname()[0]
        except OSError:
            ip_value = None
        finally:
            try:
                sock.close()
            except Exception:
                pass

    if not ip_value:
        return None

    octets = ip_value.split(".")
    network = None
    if len(octets) == 4:
        assumed = ".".join(octets[:3] + ["0"]) + "/24"
        network = assumed
    return InterfaceInfo(
        name="auto",
        cidr=f"{ip_value}/24" if network else f"{ip_value}/32",
        ip=ip_value,
        network=network,
        scope="guessed",
        is_loopback=ipaddress.ip_address(ip_value).is_loopback,
    )


def build_entries(infos: Iterable[InterfaceInfo], include_public_test: bool) -> List[str]:
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")
    lines: List[str] = [
        f"# Auto-generated by generate_targets.py on {timestamp}",
        "# Remove entries you do not want to scan or export AUTO_TARGET_DISCOVERY=0",
        "# before running run_scan.sh to disable regeneration.",
        "",
        "# Loopback (toujours accessible)",
        "127.0.0.1",
        "",
    ]

    added_primary = False
    seen_networks = set()
    for info in infos:
        if info.is_loopback:
            continue
        if not added_primary:
            lines.append(f"# Interface principale détectée ({info.name} : {info.cidr}, scope {info.scope})")
            added_primary = True
        else:
            lines.append(f"# Interface supplémentaire ({info.name} : {info.cidr}, scope {info.scope})")
        lines.append(info.ip)
        if info.network and info.network not in seen_networks:
            lines.append(info.network)
            seen_networks.add(info.network)
        lines.append("")

    if not added_primary:
        lines.append("# Aucun adaptateur non-loopback détecté ; conservez uniquement les entrées ci-dessus ou ajoutez des cibles manuellement.")
        lines.append("")

    if include_public_test:
        lines.append("# Cible publique de test (scanme.nmap.org)")
        lines.append("scanme.nmap.org")
        lines.append("")

    return lines


def write_targets(path: Path, lines: List[str]) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text("\n".join(line.rstrip() for line in lines if line is not None).strip() + "\n", encoding="utf-8")


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate a targets.txt aligned with the local host network")
    parser.add_argument(
        "--output",
        type=Path,
        default=Path(__file__).resolve().parent / "targets.txt",
        help="Chemin du fichier targets.txt à écrire (défaut : nmap_scanner/targets.txt)",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Remplacer le fichier même s'il existe déjà.",
    )
    parser.add_argument(
        "--include-public-test",
        dest="include_public_test",
        action="store_true",
        default=True,
        help="Ajouter scanme.nmap.org comme cible de validation (défaut : oui)",
    )
    parser.add_argument(
        "--no-public-test",
        dest="include_public_test",
        action="store_false",
        help="Ne pas ajouter scanme.nmap.org",
    )
    parser.add_argument("--quiet", action="store_true", help="Ne rien afficher sur stdout en cas de succès")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    output = args.output

    if output.exists() and not args.force:
        print(
            f"[INFO] {output} existe déjà. Utilisez --force pour le remplacer ou modifiez-le manuellement.",
            file=sys.stderr,
        )
        return 0

    infos = discover_interfaces()
    if not infos:
        fallback = fallback_interface_guess()
        if fallback:
            infos = [fallback]

    lines = build_entries(infos, include_public_test=args.include_public_test)
    write_targets(output, lines)

    if not args.quiet:
        print(f"[OK] Fichier cible écrit dans {output}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
